/**
 * 	Autores:f
 *	Fecha ultima revision:
 * 	Comentarios:
 */
options
{
  static = true;
  ignore_case = true;
}

PARSER_BEGIN(CompiladorMiniLeng)

public class CompiladorMiniLeng
{
  public static void main(String args []) throws ParseException
  {
    //CompiladorMiniLeng parser = new CompiladorMiniLeng(System.in);
    CompiladorMiniLeng parser = new CompiladorMiniLeng(new FileInputStream(args[0]));
	System.out.println("Leyendo de la entrada estandar...");
    try { 
    	CompiladorMiniLeng.programa();
    	System.out.println("Analizado correctamente");
    }
    catch (TokenMgrError e) {
		//Error léxico
		try {
			System.out.println("ERROR LÉXICO ("
			+ SimpleCharStream.getBeginLine()
			+ ", "
			+ SimpleCharStream.getBeginColumn()
			+ "): Símbolo no reconocido: "
			+ SimpleCharStream.readChar()
			);
		} catch (Exception ex) {
			// Excepcion por readChar
			System.out.println(ex.getMessage());
		}
	}
	catch (ParseException e) {
		//Error sintáctico
		System.out.println("Error sintáctico!");
        System.out.println(e.getMessage());
        CompiladorMiniLeng.ReInit(System.in);
	} 
    catch (Error e) {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
	}
  }
}

PARSER_END(CompiladorMiniLeng)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| <"%" (~["\n", "\r"])*>
| <"%%" (~[])* "%%">
}

TOKEN : /* AGRUPACIONES */
{
  <  tLLAVE_IZQ : "{" >
  {
    System.out.println("LLAVE_IZQ");
  }
| <  tLLAVE_DCHA : "}" >
  {
    System.out.println("LLAVE_DCHA");
  }
}

// ADICION NUESTRA.

TOKEN : /*  */
{
  < tPROGRAMA : "programa">
  {
    System.out.println("programa");
  }
| < tVAR : "var">
  {
    System.out.println("var");
  }
| < tPRINCIPIO : "principio">
  {
    System.out.println("principio");
  }
| < tFIN : "fin">
  {
    System.out.println("fin");
  }
| < tSI: "si" >
  {
    System.out.println("si");
  }
| < tENT: "ent" >
  {
    System.out.println("ent");
  }
| < tSI_NO: "si_no" >
  {
    System.out.println("si_no");
  }
| < tFSI : "fsi">
  {
    System.out.println("fsi");
  }
| < tMQ : "mq" >
  {
    System.out.println("mq");
  }
| < tFMQ : "fmq" >
  {
    System.out.println("fmq");
  }
}

TOKEN: /* E/S */
{
  < tESCRIBIR : "escribir" >
| < tLEER : "leer" >
}

TOKEN : /* Operador multiplicativo  */
{
  < tAND : "and" >
  {
    System.out.println("AND");
  }
| < tMOD : "mod" >
{
  System.out.println("MOD");
}
| < tOR : "or" >
{
  System.out.println("OR");
}
| < tNOT : "not" >
{
  System.out.println("NOT");
}
}

TOKEN : /*tipo_variables */
{
  < tENTERO : "entero" >
  {
    System.out.println("ENTERO");
  }
| < tBOOLEANO : "booleano" >
{
  System.out.println("BOOLEANO");
}
| < tCARACTER : "caracter" >
{
  System.out.println("CARACTER");
}
}

TOKEN : /*valor booleano*/
{
  < tTRUE : "true" >
  {
    System.out.println("TRUE");
  }
| < tFALSE : "false" >
{
  System.out.println("FALSE");
} 
}

TOKEN : /* conversion de tipo entero y caracter */
{
  < tENTACAR : "entacar" >
  {
    System.out.println("ENTACAR");
  }
| < tCARAENT : "caraent" >
{
  System.out.println("CARAENT");
}
}

TOKEN: /* accion */
{
  < tACCION : "accion" >
  {
    System.out.println("ACCION");
  }
}

TOKEN : /* clase_parametros */
{
  < tVAL : "val" >
  {
    System.out.println("VAL");
  }
| < tREF : "ref" >
{
  System.out.println("REF");
}
}

TOKEN : /* operador_relacional */
{
  < tMAYOR : ">" >
  {
    System.out.println(">");
  }
| < tMENOR : "<" >
{
  System.out.println("<");
}
| < tIGUAL : "=" >
{
  System.out.println("=");
}
| < tMAI : ">=" >
{
  System.out.println(">=");
}
| < tMEI : "<=" >
{
  System.out.println("<=");
}
| < tNI : "<>" >
{
  System.out.println("<>");
}
}

TOKEN : /* otros */
{
	< tOPAS : ":=" >
{
  System.out.println(":=");
}
| < tFIN_SENTENCIA : ";" >
  {
    System.out.println("FIN_SENTENCIA");
  }
| < tCOMA : "," >
  {
  	System.out.println("coma");
  }
| < tPARENTESIS_IZQ : "(" >
  {
    System.out.println("(");
  }
| < tPARENTESIS_DCH : ")" >
  {
    System.out.println(")");
  }
}

TOKEN: /* Operadores aritméticos */
{
  < tMAS : "+">
  {
    System.out.println("MAS");
  }
| < tMENOS : "-" >
  {
    System.out.println("MENOS");
  }
| < tDIV : "/" >
  {
    System.out.println("/");
  }
| < tMUL : "*" >
  {
    System.out.println("*");
  }
}

TOKEN : /* VALORES */
{
  < #DIGITO : ["0"-"9"] >
| < #LETRA : ["a"-"z","_","0"-"9"] >
| < tCONSTENTERA : (< DIGITO >)+ >
  {
    System.out.println("VALOR_ENTERO (Valor: " + matchedToken + ")");
  }
| < tCONSTCHAR : "\"" < LETRA > "\"">
  {
    System.out.println("IDENTIFICADOR (Caracter : " + matchedToken + ")");
  }
| < tCONSTCAD : "\"" (< LETRA >)* "\"">
  {
    System.out.println("IDENTIFICADOR (Cadena : " + matchedToken + ")");
  }
| <  tIDENTIFICADOR : (["a"-"z"] | ("_")+ (["a"-"z","0"-"9"])) (["a"-"z", "0"-"9"] | ( ("_")+ (["a"-"z","0"-"9"]) ) )* >
  {
    System.out.println("IDENTIFICADOR (Valor: " + matchedToken + ")");
  }
}

void programa ():
{}
{
	try {
	  <tPROGRAMA> <tIDENTIFICADOR> <tFIN_SENTENCIA> declaracion() declaracion_acciones() bloque_sentencias() < EOF >
	}
    catch (ParseException e) {
      try {
		System.out.println("ERROR SINTÁCTICO ("
		+ e.currentToken.next.beginLine
		+ ", "
		+ e.currentToken.next.beginColumn
		+ ") : "
		+ e.currentToken.next.image
		+ " "
		+ e.expectedTokenSequences
		);

		Token t;
		System.out.println(e.toString());
		do {
		t = getNextToken();
		} while (t.kind != tFIN_SENTENCIA && t!=null && t.kind != EOF );
	  } catch (Exception ex) {}
	}
  
}

void declaracion_variables():
{}
{
  ( declaracion() ";" )*
}

void declaracion ():
{}
{
  tipo_variables() identificadores()
}

void identificadores():
{}
{
  <tIDENTIFICADOR> ( "," <tIDENTIFICADOR> )*
}

void tipo_variables():
{}
{
   <tENTERO> | <tCARACTER> | <tBOOLEANO>
}

void declaracion_acciones():
{}
{
  (declaracion_accion())*
}

void declaracion_accion():
{}
{
  cabecera_accion() < tFIN_SENTENCIA > declaracion() declaracion_acciones() bloque_sentencias()
}

void cabecera_accion():
{}
{
	<tACCION> <tIDENTIFICADOR> ( parametros_formales() )?
}

void parametros_formales() :
{}
{
  "(" parametros() ")" ";"
}

void lista_parametros():
{}
{
  <tIDENTIFICADOR> ("," <tIDENTIFICADOR>)* 
}

void parametros():
{}
{
  < tVAL > tipo_variables() lista_parametros() ( < tFIN_SENTENCIA >parametros() )?
| < tREF > tipo_variables() lista_parametros() ( < tFIN_SENTENCIA >parametros() )?
}



void bloque_sentencias():
{}
{
  <tPRINCIPIO> lista_sentencias() <tFIN>
}

void lista_sentencias():
{}
{
  ( sentencia() )+
}

void sentencia():
{}
{
  leer() < tFIN_SENTENCIA >
| escribir() < tFIN_SENTENCIA >
| <tIDENTIFICADOR> asig_incaccion()
| seleccion()
| mientras_que()
}

void leer():
{}
{
  <tLEER> <tPARENTESIS_IZQ > lista_asignables() < tPARENTESIS_DCH >
}

void lista_asignables():
{}
{
  <tIDENTIFICADOR> ("," <tIDENTIFICADOR>)*
}

void lista_escribibles():
{}
{
  lista_expresiones()
}

void escribir():
{}
{
  <tESCRIBIR> <tPARENTESIS_IZQ> lista_escribibles() <tPARENTESIS_DCH>
}

void asig_incaccion():
{}
{
  asignacion() | invocacion_accion()
}

void asignacion():
{}
{
  <tOPAS> expresion() < tFIN_SENTENCIA >
}

void invocacion_accion():
{}
{
  argumentos() < tFIN_SENTENCIA >
}

void mientras_que():
{}
{
  <tMQ> expresion() lista_sentencias() <tFMQ>
}

void seleccion():
{}
{
  <tSI> expresion() <tENT> lista_sentencias() ( <tSI_NO> lista_sentencias())? <tFSI>
}

void argumentos():
{}
{
  < tPARENTESIS_IZQ > ( lista_expresiones() )? < tPARENTESIS_DCH >
}

void lista_expresiones():
{}
{
  expresion() ("," expresion())*
}

void expresion():
{}
{
  expresion_simple() ( operador_relacional() expresion_simple() )?
}

void operador_relacional():
{}
{
  <tIGUAL> | <tNI> | <tMENOR> | <tMAYOR> | <tMEI> | <tMAI>
}

void expresion_simple():
{}
{
  ("+" | "-")? termino() ( operador_aditivo() termino() )*
}

void operador_aditivo():
{}
{
	< tMAS > | < tMENOS > | <tOR>
}

void termino():
{}
{
  factor() ( operador_multiplicativo() factor() )*
}

void operador_multiplicativo():
{}
{
  < tMUL > | <tDIV> | <tMOD> | <tAND>
}

void factor():
{}
{
	<tNOT> factor()
    | "(" expresion() ")"
    | <tENTACAR> "(" expresion() ")"
    | <tCARAENT> "(" expresion() ")"
    | <tIDENTIFICADOR>
    | <tCONSTENTERA>
    | <tCONSTCHAR>
    | <tCONSTCAD>
    | <tTRUE>
    | <tFALSE>
}
